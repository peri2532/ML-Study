# 행렬의 기본 연산과 사다리꼴

##  1. 행렬의 기본 연산

### 기본 행 연산
    - 어떤 행렬 A의 다음 세가지 타입의 연산들을 기본 행 연산이라고 한다.
    1) Type 1 : 어떤 2개의 행을 서로 바꾼다.
    2) Type 2 : 어떤 행에다 0이 아닌 상수를 곱한다.
    3) Type 3 : 어떤 행에다 상수를 곱한 후 다른 행에다 더한다.

### 왜 기본 행 연산이 중요한가?

- 기본 행 연산은 선형방정식의 해를 바꾸지 않는다.
- 즉, 해집합을 보존하면서 문제를 단순화하는 도구이다.
- 이는 연립방정식을 푸는 알고리즘의 핵심이다.

## 선형독립의 ML 의미

- 어떤 feature가 다른 feature들의 선형결합으로 표현되면 정보가 중복된다.
- 이는 회귀모델에서 불안정한 계수 추정을 만든다.
- 따라서 feature들은 가능한 한 선형독립인 것이 좋다.

## ML 연결

- 선형회귀는 결국 연립방정식 Xβ = y 를 푸는 문제이다.
- 가우스 소거법은 이런 선형시스템을 푸는 기본 알고리즘이다.


## 행 동치
    - 기본 행 연산을 필요에 따라 한 번 또는 여러 번 거친 것

## 기본 행렬
    - n*n 항등 행렬에서 한 번의 기본 행 연산을 거쳐 만들어지는 n*n 행렬을 기본행렬

## 피벗(선행자)
    -각 0이 아닌 행에서 가장 왼쪽의 0이 아닌 원소를 피벗이라 한다.
## 행 사다리꼴의 의미

- 행렬을 "계단 형태"로 정리하면
  선형독립 여부와 해의 구조가 보인다.

- 피벗의 위치는
  독립적인 방향(기저)을 의미한다.
## 행 사다리꼴(REF)
    - (m*n 행렬 A가 기본 행 연산자들을 거친 후 다음 3가지 조건을 만족시키면 행 사다리꼴)
    1) 0으로만 이루어진 행들은, 만약 있는 경우, 행렬의 아래쪽에 나타낸다.
    2) 모두가 0은 아닌 행의 가장 왼쪽에 가장 처음 나타나는 0이 아닌 수를 피벗으로 삼는다.
    3) 모두가 0은 아닌 연이은 두 행이 있으면 아래쪽 행의 피벗은 위쪽 행의 피벗보다 오른쪽에 있다.

## 기약 행 사다리꼴(RREF)
    -행 사다리꼴의 3가지 조건에다 다음의 4번쨰 조건까지 만족시키면 기약 행 사다리꼴이라고 한다.
    - 각 행의 피벗을 포함하는 열에는 피벗 이외의 항들은 모두 0이다.

## 기약 행 사다리꼴을 구하기 위한 기본 행 연산 방법
    1) 전향단계
        - 피벗의 아랫부분이 0이 되도록 한다.
    2) 후향단계
        - 피벗의 윗부분까지 0이 되도록 행 연산을 실행한다.
### 가우스 소거법
    - 전향 단계까지만 연산과정을 실행하면 행 사다리꼴을 구할 수 있는데, 이를 가우스 소거법이라고 한다.

### 가우스-조단 소거법
    -전향단계에다가 후향단계까지 실행하면 가우스-조단 소거법이라고 한다.

## 계수(rank)
    -주어진 행렬을 행 사다리꼴로 만들었을때 행 전체가 0이 아닌 행의 개수
    - 행 사다리꼴에서의 피벗의 개수와도 같다.
    -n차 정방행렬인 경우에 Rank(A) =n이면 역행렬이 존재함(중요)
## Rank의 구조적 의미

- Rank(A)는 A의 열공간(column space)의 차원이다.
- 즉, A가 만들어내는 독립적인 방향의 개수이다.

- Rank가 낮다는 것은
  정보가 중복되어 있다는 뜻이다.

## ML 연결 (매우 중요)

- 선형회귀에서 X의 rank가 부족하면
  (rank(X) < 열의 개수)
  역행렬 (X^T X)^{-1}이 존재하지 않는다.

- 이는 다중공선성(multicollinearity) 문제와 연결된다.

- 차원축소(PCA)는
  rank를 줄이는 과정이라고 볼 수 있다.

## 인접행렬
    -어떤 점 i에서 점 j로의 연결이 있을 경우를 행렬로 나타낸 것

## 선형독립
    - 어떤 벡터도 다른 벡터들의 선형결합으로 표현되지 않을 때 선형독립이라 한다.

### 문제 1

-rank(A) = rank(A^T)임을 입증하시오.

### 문제 1 답

- rank는 행렬에서 선형독립인 행의 최대 개수이며, 행 사다리꼴에서의 피벗의 개수로 계산할 수 있다.
행렬 A를 기본 행 연산을 통해 행 사다리꼴 R로 만들면
rank(A) = 피벗의 개수
가 된다.
- 기본 행 연산은 rank를 변화시키지 않으므로,
rank(A) = rank(R)
이다.
- 전치행렬 A^T도 하나의 행렬이므로 rank가 항상 정의된다.
A^T 역시 기본 행 연산을 통해 행 사다리꼴로 만들 수 있고,
그 피벗의 개수를 세면
rank(A^T)
를 구할 수 있다.
- A와 A^T 각각에 대해 행 사다리꼴을 만들면 피벗의 개수를 계산할 수 있다.
기본 행 연산은 rank를 보존하므로 계산 과정에서 rank는 변하지 않는다.
- 따라서
rank(A) = rank(A^T)
이다.
## rank(A) = rank(A^T)의 핵심 아이디어

- rank(A)는 A의 행공간(row space)의 차원이다.
- rank(A^T)는 A의 열공간(column space)의 차원이다.

- 선형대수의 기본정리:
  행공간과 열공간의 차원은 항상 같다.

- 따라서
  rank(A) = rank(A^T)
### 깨달은점

- 내가 헷갈린 점
    - 전치한 직후의 행렬이 행 사다리꼴이 아니면 rank가 정의되지 않는다고 생각함
    - 그래서 전치 직후 상태에서 바로 판단해야한다고 생각했다.
    - 전치 후 다시 기본 행 연산을 하는것이 옳은건지 헷갈렸다.
- 깨달은 점
    - rank는 모든 행렬에 대해 항상 정의되는 값
    - 기본 행 연산은 rank를 변화시키지 않음
    - 따라서 전치 후 다시 행 사다리꼴로 만드는 것은 값을 바꾸는 것이 아니라 계산을 쉽게 하기 위한 과정이다.